import os
import json
import requests
from google.colab import userdata
import subprocess

from datetime import datetime, timedelta
from crewai import LLM
from crewai import Agent, Task, Crew, Process
from crewai.tools import tool
from crewai_tools import ScrapeWebsiteTool
from crewai_tools import SerperDevTool

# -------------------------
# 1) CONFIGURATION & ENVIRONMENT
# -------------------------
OPENAI_KEY = userdata.get("OPENAI_API_KEY")
FMP_KEY = userdata.get("FMP_API_KEY")
SERPER_KEY = userdata.get("SERPER_API_KEY")
# XAI_KEY = userdata.get("XAI_API_KEY")
# grok_llm = None
# if XAI_KEY:
#     grok_llm = LLM(
#         model="xai/grok-4",
#         api_key=str(XAI_KEY),
#         base_url="https://api.x.ai/v1",
#         temperature=0.2,
#         max_tokens=3500
#     )


if not SERPER_KEY:
    raise ValueError("Missing SERPER_API_KEY in Colab Secrets (key icon).")
if not OPENAI_KEY:
    raise ValueError("Missing OPENAI_API_KEY in Colab Secrets (key icon).")
if not FMP_KEY:
    raise ValueError("Missing FMP_API_KEY in Colab Secrets (key icon).")

os.environ["SERPER_API_KEY"] = str(SERPER_KEY)
os.environ["OPENAI_API_KEY"] = str(OPENAI_KEY)
os.environ["FMP_API_KEY"] = str(FMP_KEY)
os.environ["OTEL_SDK_DISABLED"] = "true"

scrape_tool = ScrapeWebsiteTool()
search_tool = SerperDevTool()
session = requests.Session()
session.headers.update({"User-Agent": "colab-crewai-fmp/1.0"})


def _get_json(url: str, params: dict, timeout: int = 30):
    """Fetch JSON with good error visibility."""
    try:
        r = session.get(url, params=params, timeout=timeout)
        text = r.text
        try:
            payload = r.json()
        except Exception:
            payload = {"_non_json_response": text[:1200]}

        if r.status_code != 200:
            return {"ok": False, "status_code": r.status_code, "url": r.url, "error_payload": payload}

        return {"ok": True, "data": payload, "url": r.url}
    except Exception as e:
        return {"ok": False, "exception": str(e), "url": url}


def _pick_latest_filing(filings: list):
    """
    Pick the latest 10-Q if available, else latest 10-K, else None.
    Works best if filingDate is present.
    """
    if not isinstance(filings, list) or not filings:
        return None

    def _date_key(f):
        # FMP often uses 'fillingDate' (note spelling), sometimes 'filingDate'
        d = f.get("fillingDate") or f.get("filingDate") or ""
        return d

    tens_q = [f for f in filings if (f.get("type") or f.get("formType") or "").upper() in ("10-Q", "10Q")]
    tens_k = [f for f in filings if (f.get("type") or f.get("formType") or "").upper() in ("10-K", "10K")]

    if tens_q:
        return sorted(tens_q, key=_date_key, reverse=True)[0]
    if tens_k:
        return sorted(tens_k, key=_date_key, reverse=True)[0]
    return sorted(filings, key=_date_key, reverse=True)[0]


def _latest_transcript(symbol: str, api_key: str):
    """
    Find newest available transcript via stable endpoints:
      1) /stable/earning-call-transcript-dates?symbol=...
      2) /stable/earning-call-transcript?symbol=...&year=...&quarter=...
    """
    STABLE = "https://financialmodelingprep.com/stable"

    dates_resp = _get_json(
        f"{STABLE}/earning-call-transcript-dates",
        {"symbol": symbol, "apikey": api_key},
    )
    if not dates_resp.get("ok"):
        return {"available": False, "note": "Failed to fetch transcript dates.", "debug": dates_resp}

    dates = dates_resp.get("data")
    if not isinstance(dates, list) or not dates:
        return {"available": False, "note": "No transcript dates returned for this symbol.", "debug_url": dates_resp.get("url")}

    latest = max(
        dates,
        key=lambda d: (
            int(d.get("fiscalYear") or d.get("year") or 0),
            int(d.get("quarter") or 0)
        )
    )

    year = latest.get("fiscalYear") or latest.get("year")
    quarter = latest.get("quarter")

    if year is None or quarter is None:
        return {"available": False, "note": "Transcript dates missing year/quarter.", "latest_row": latest, "debug_url": dates_resp.get("url")}

    t_resp = _get_json(
        f"{STABLE}/earning-call-transcript",
        {"symbol": symbol, "year": year, "quarter": quarter, "apikey": api_key},
    )
    if not t_resp.get("ok"):
        return {"available": False, "note": "Failed to fetch transcript.", "year": year, "quarter": quarter, "debug": t_resp}

    t_data = t_resp.get("data")
    if not isinstance(t_data, list) or not t_data:
        return {"available": False, "note": "Transcript returned no rows.", "year": year, "quarter": quarter, "debug_url": t_resp.get("url")}

    content = (t_data[0].get("content") or "").strip()
    if not content:
        return {"available": False, "note": "Transcript content empty.", "year": year, "quarter": quarter, "debug_url": t_resp.get("url")}

    return {"available": True, "year": year, "quarter": quarter, "date": t_data[0].get("date"), "excerpt": content[:8000], "debug_url": t_resp.get("url")}


def _compute_business_phase(phase_inputs: dict):
    """
    Your decision tree + a practical Phase 3 insertion:
    - Phase 5 if capital returns (dividends OR buybacks) present.
    - Phase 6 if revenue declining (YoY < 0) AND operating income positive or near.
    - Phase 1/2 for negative op income (worse vs prior => startup, improving => hypergrowth),
      BUT if near breakeven => Phase 3.
    - Phase 4 for positive op income & revenue flat/growing,
      BUT if near breakeven => Phase 3.
    """
    rev_now = phase_inputs.get("revenue_current")
    rev_prev = phase_inputs.get("revenue_prior")
    op_now = phase_inputs.get("op_income_current")
    op_prev = phase_inputs.get("op_income_prior")
    dividends_paid = phase_inputs.get("dividends_paid")
    buybacks = phase_inputs.get("buybacks")

    # Capital returns flag
    capital_returns = False
    capital_details = []
    # Cash flow fields are often negative when paid out
    if isinstance(dividends_paid, (int, float)) and dividends_paid != 0:
        capital_returns = True
        capital_details.append(f"DividendsPaid={dividends_paid:,.0f}")
    if isinstance(buybacks, (int, float)) and buybacks != 0:
        capital_returns = True
        capital_details.append(f"CommonStockRepurchased={buybacks:,.0f}")

    # Revenue growth
    rev_growth = None
    if isinstance(rev_now, (int, float)) and isinstance(rev_prev, (int, float)) and rev_prev != 0:
        rev_growth = (rev_now - rev_prev) / abs(rev_prev)

    # Operating margin for breakeven detection
    op_margin = None
    if isinstance(op_now, (int, float)) and isinstance(rev_now, (int, float)) and rev_now != 0:
        op_margin = op_now / rev_now  # e.g., 0.10 = 10%

    # Confidence heuristic
    have_core = (rev_now is not None and rev_prev is not None and op_now is not None and op_prev is not None)
    have_capital = (dividends_paid is not None or buybacks is not None)

    # Phase logic
    if capital_returns:
        phase = 5
        name = "CAPITAL RETURN"
        emoji = "üí∞"
        rationale = "Returning capital (dividends or buybacks)."
    else:
        # Handle missing core numbers
        if not have_core:
            phase = None
            name = "UNKNOWN"
            emoji = "‚ùì"
            rationale = "Insufficient data to classify reliably."
        else:
            # Near breakeven check (Phase 3)
            near_breakeven = (op_margin is not None and abs(op_margin) <= 0.03)

            # Operating income negative?
            if op_now < 0:
                if near_breakeven:
                    phase = 3
                    name = "SELF FUNDING"
                    emoji = "üß©"
                    rationale = "Near breakeven operating income (self-funding zone)."
                else:
                    # Losses worse (more negative) vs prior => Startup
                    if op_prev is not None and op_now < op_prev:
                        phase = 1
                        name = "STARTUP"
                        emoji = "üöÄ"
                        rationale = "Losses expanding."
                    else:
                        phase = 2
                        name = "HYPERGROWTH"
                        emoji = "‚ö°"
                        rationale = "Losses improving."
            else:
                # Positive op income
                if rev_growth is not None and rev_growth < 0:
                    phase = 6
                    name = "DECLINE"
                    emoji = "üìâ"
                    rationale = "Revenue declining."
                else:
                    if near_breakeven:
                        phase = 3
                        name = "SELF FUNDING"
                        emoji = "üß©"
                        rationale = "Near breakeven operating income (self-funding zone)."
                    else:
                        phase = 4
                        name = "OPERATING LEVERAGE"
                        emoji = "üìà"
                        rationale = "Profitable with stable/growing revenue."

    # Confidence
    if phase is None:
        confidence = "‚ùå Low"
    else:
        if have_core and have_capital:
            confidence = "‚úÖ High"
        elif have_core:
            confidence = "‚ö†Ô∏è Medium"
        else:
            confidence = "‚ùå Low"

    return {
        "phase": phase,
        "phase_name": name,
        "emoji": emoji,
        "confidence": confidence,
        "rationale": rationale,
        "capital_returns": {
            "yes": capital_returns,
            "details": capital_details
        },
        "computed": {
            "revenue_growth_yoy": rev_growth,
            "operating_margin": op_margin
        }
    }

def md_to_pdf_pandoc(md_path: str, pdf_path: str, title: str = None):
    cmd = [
        "pandoc",
        md_path,
        "-o", pdf_path,
        "--pdf-engine=xelatex",
        "--toc",
        "--number-sections",
        "-V", "geometry:margin=1in",
        "-V", "fontsize=11pt",
    ]
    if title:
        cmd += ["-M", f"title={title}"]
    subprocess.run(cmd, check=True)
    return pdf_path


# -------------------------
# 2) CUSTOM DATA TOOL (FMP API) ‚Äî upgraded for business phase
# -------------------------
@tool("investment_data_tool")
def investment_data_tool(symbol: str) -> str:
    """
    Fetches comprehensive data for a ticker from FMP API:
    - Earnings transcript (Qualitative)
    - SEC filing links (10-K, 10-Q, Proxy)
    - Key TTM metrics
    - Financial growth data
    - Income statement + cash flow (for business phase)
    """
    api_key = os.environ.get("FMP_API_KEY")
    if not api_key:
        return json.dumps({"error": "Missing FMP_API_KEY env var"}, indent=2)

    symbol = (symbol or "").strip().upper()
    if not symbol:
        return json.dumps({"error": "No symbol provided"}, indent=2)

    base_v3 = "https://financialmodelingprep.com/api/v3"

    # Transcript (fixed)
    transcript_obj = _latest_transcript(symbol, api_key)

    # Profile for company name (helps your template)
    profile_resp = _get_json(f"{base_v3}/profile/{symbol}", {"apikey": api_key})
    profile_data = profile_resp.get("data") if profile_resp.get("ok") else None
    company_name = None
    if isinstance(profile_data, list) and profile_data:
        company_name = profile_data[0].get("companyName") or profile_data[0].get("companyName")

    # SEC Filings
    filings_resp = _get_json(f"{base_v3}/sec_filings/{symbol}", {"limit": 25, "apikey": api_key})
    filings_data = filings_resp.get("data") if filings_resp.get("ok") else None

    sec_links = []
    latest_filing = None
    if isinstance(filings_data, list):
        for f in filings_data[:8]:
            ftype = f.get("type") or f.get("formType") or "Unknown"
            link = f.get("finalLink") or f.get("link") or f.get("url")
            if link:
                sec_links.append(f"{ftype}: {link}")
        latest_filing = _pick_latest_filing(filings_data)

    latest_sec_url = None
    latest_sec_label = None
    latest_sec_date = None
    if latest_filing:
        latest_sec_label = latest_filing.get("type") or latest_filing.get("formType")
        latest_sec_date = latest_filing.get("fillingDate") or latest_filing.get("filingDate")
        latest_sec_url = latest_filing.get("finalLink") or latest_filing.get("link") or latest_filing.get("url")

    # Key Metrics (TTM)
    metrics_resp = _get_json(f"{base_v3}/key-metrics-ttm/{symbol}", {"apikey": api_key})
    metrics_data = metrics_resp.get("data") if metrics_resp.get("ok") else None
    metrics = metrics_data[0] if isinstance(metrics_data, list) and metrics_data else None

    # Financial Growth (latest)
    growth_resp = _get_json(f"{base_v3}/financial-growth/{symbol}", {"limit": 1, "apikey": api_key})
    growth_data = growth_resp.get("data") if growth_resp.get("ok") else None
    growth = growth_data[0] if isinstance(growth_data, list) and growth_data else None

    # Income statement (annual, last 2)
    inc_resp = _get_json(
        f"{base_v3}/income-statement/{symbol}",
        {"period": "annual", "limit": 2, "apikey": api_key},
    )
    inc_data = inc_resp.get("data") if inc_resp.get("ok") else None

    # Cash flow statement (annual, last 1)
    cf_resp = _get_json(
        f"{base_v3}/cash-flow-statement/{symbol}",
        {"period": "annual", "limit": 1, "apikey": api_key},
    )
    cf_data = cf_resp.get("data") if cf_resp.get("ok") else None

    # Phase inputs
    revenue_current = revenue_prior = None
    op_income_current = op_income_prior = None

    if isinstance(inc_data, list) and len(inc_data) >= 1:
        revenue_current = inc_data[0].get("revenue")
        op_income_current = inc_data[0].get("operatingIncome")
    if isinstance(inc_data, list) and len(inc_data) >= 2:
        revenue_prior = inc_data[1].get("revenue")
        op_income_prior = inc_data[1].get("operatingIncome")

    dividends_paid = buybacks = None
    if isinstance(cf_data, list) and cf_data:
        # Common field names from FMP:
        dividends_paid = cf_data[0].get("dividendsPaid")
        buybacks = cf_data[0].get("commonStockRepurchased")

    phase_inputs = {
        "revenue_current": revenue_current,
        "revenue_prior": revenue_prior,
        "op_income_current": op_income_current,
        "op_income_prior": op_income_prior,
        "dividends_paid": dividends_paid,
        "buybacks": buybacks,
        "latest_sec_url": latest_sec_url,
        "latest_sec_label": latest_sec_label,
        "latest_sec_date": latest_sec_date,
    }

    phase_classification = _compute_business_phase(phase_inputs)

    out = {
        "symbol": symbol,
        "company_name": company_name,
        "business_phase_inputs": phase_inputs,
        "business_phase_classification": phase_classification,
        "transcript": transcript_obj,
        "sec_links": sec_links,
        "metrics": metrics or {"note": "No metrics returned", "debug": metrics_resp if not metrics_resp.get("ok") else None},
        "growth": growth or {"note": "No growth data returned", "debug": growth_resp if not growth_resp.get("ok") else None},
        "debug": {
            "profile_url": profile_resp.get("url"),
            "filings_url": filings_resp.get("url"),
            "metrics_url": metrics_resp.get("url"),
            "growth_url": growth_resp.get("url"),
            "income_statement_url": inc_resp.get("url"),
            "cash_flow_url": cf_resp.get("url"),
        }
    }
    return json.dumps(out, ensure_ascii=False, indent=2)

@tool("price_sentiment_data_tool")
def price_sentiment_data_tool(symbol: str) -> str:
    """
    Computes 1-year price performance metrics needed for the sentiment template:
    - 1Y % change
    - 52-week range
    - current price
    - vs 50/200-day SMA (approx from latest SMA values)
    - vs S&P 500 (uses ^GSPC if available)
    """
    api_key = os.environ.get("FMP_API_KEY")
    if not api_key:
        return json.dumps({"error": "Missing FMP_API_KEY"}, indent=2)

    symbol = (symbol or "").strip().upper()
    if not symbol:
        return json.dumps({"error": "No symbol provided"}, indent=2)

    base_v3 = "https://financialmodelingprep.com/api/v3"

    end = datetime.utcnow().date()
    start = end - timedelta(days=365)

    # Current quote
    q = _get_json(f"{base_v3}/quote/{symbol}", {"apikey": api_key})
    quote = (q.get("data") or [])
    current_price = quote[0].get("price") if isinstance(quote, list) and quote else None

    # 1Y daily history (line)
    hist = _get_json(
        f"{base_v3}/historical-price-full/{symbol}",
        {"from": str(start), "to": str(end), "serietype": "line", "apikey": api_key},
    )
    h = (hist.get("data") or {}).get("historical") if hist.get("ok") and isinstance(hist.get("data"), dict) else None

    one_year_change = None
    low_52w = None
    high_52w = None
    first_close = last_close = None
    if isinstance(h, list) and len(h) >= 2:
        # FMP often returns newest->oldest, sort by date ascending
        h_sorted = sorted(h, key=lambda r: r.get("date") or "")
        first_close = h_sorted[0].get("close")
        last_close = h_sorted[-1].get("close")
        closes = [r.get("close") for r in h_sorted if isinstance(r.get("close"), (int, float))]
        if closes:
            low_52w = min(closes)
            high_52w = max(closes)
        if isinstance(first_close, (int, float)) and isinstance(last_close, (int, float)) and first_close != 0:
            one_year_change = (last_close - first_close) / abs(first_close)

    # SMA 50 / 200 from technical indicator daily endpoint :contentReference[oaicite:5]{index=5}
    def _latest_sma(period: int):
        r = _get_json(
            f"{base_v3}/technical_indicator/daily/{symbol}",
            {"type": "sma", "period": period, "apikey": api_key},
        )
        data = r.get("data")
        if r.get("ok") and isinstance(data, list) and data:
            # newest first typically
            return data[0].get("sma")
        return None

    sma50 = _latest_sma(50)
    sma200 = _latest_sma(200)

    def _vs_ma(px, ma):
        if not isinstance(px, (int, float)) or not isinstance(ma, (int, float)) or ma == 0:
            return None
        # keep it categorical for your template
        if abs(px - ma) / abs(ma) <= 0.005:
            return "At"
        return "Above" if px > ma else "Below"

    vs50 = _vs_ma(current_price, sma50)
    vs200 = _vs_ma(current_price, sma200)

    # S&P 500 compare (best-effort, may fail depending on FMP symbol support)
    spx_symbol = "^GSPC"
    spx_hist = _get_json(
        f"{base_v3}/historical-price-full/{spx_symbol}",
        {"from": str(start), "to": str(end), "serietype": "line", "apikey": api_key},
    )
    spx_h = (spx_hist.get("data") or {}).get("historical") if spx_hist.get("ok") and isinstance(spx_hist.get("data"), dict) else None
    spx_change = None
    if isinstance(spx_h, list) and len(spx_h) >= 2:
        spx_sorted = sorted(spx_h, key=lambda r: r.get("date") or "")
        spx_first = spx_sorted[0].get("close")
        spx_last = spx_sorted[-1].get("close")
        if isinstance(spx_first, (int, float)) and isinstance(spx_last, (int, float)) and spx_first != 0:
            spx_change = (spx_last - spx_first) / abs(spx_first)

    out = {
        "symbol": symbol,
        "window": {"start": str(start), "end": str(end)},
        "current_price": current_price,
        "one_year_change_pct": (one_year_change * 100) if isinstance(one_year_change, (int, float)) else None,
        "range_52w": {"low": low_52w, "high": high_52w},
        "moving_averages": {"sma50": sma50, "sma200": sma200, "vs50": vs50, "vs200": vs200},
        "sp500": {
            "symbol": spx_symbol,
            "one_year_change_pct": (spx_change * 100) if isinstance(spx_change, (int, float)) else None,
        },
        "debug": {
            "quote_url": q.get("url"),
            "hist_url": hist.get("url"),
            "sma50_url": f"{base_v3}/technical_indicator/daily/{symbol}?type=sma&period=50&apikey=***",
            "sma200_url": f"{base_v3}/technical_indicator/daily/{symbol}?type=sma&period=200&apikey=***",
            "spx_hist_url": spx_hist.get("url"),
        },
    }
    return json.dumps(out, ensure_ascii=False, indent=2)



# -------------------------
# 3) AGENTS
# -------------------------
phase_classifier = Agent(
    role="Business Phase Classifier",
    goal="Classify the company into the correct growth phase using operating income dynamics and capital returns.",
    backstory="You are a disciplined financial analyst who follows a decision tree and outputs only the required template.",
    tools=[investment_data_tool, scrape_tool],
    verbose=True,
    allow_delegation=False,
)

sentiment_analyst = Agent(
    role="Price & Sentiment Analyst",
    goal="Explain why the stock moved over the last year and where sentiment sits now, with verifiable links and no speculation.",
    backstory="You are a strict, evidence-first analyst. You never invent data or links. You separate facts from interpretation.",
    tools=[price_sentiment_data_tool, search_tool, scrape_tool],
    verbose=True,
    allow_delegation=False,
)

strategist = Agent(
    role="Business & Moat Analyst",
    goal="Identify Moat Strength and Growth Sources, consistent with the company‚Äôs phase.",
    backstory="Expert in competitive strategy. You analyze pricing power, network effects, switching costs, and lifecycle stages.",
    tools=[investment_data_tool, search_tool, scrape_tool],
    verbose=True,
    allow_delegation=False,
)

governance_expert = Agent(
    role="Governance & Risk Specialist",
    goal="Evaluate management alignment and execution risks.",
    backstory="Forensic analyst focused on executive compensation, incentives, and management candor.",
    tools=[investment_data_tool, search_tool, scrape_tool],
    verbose=True,
    allow_delegation=False,
)

quant_auditor = Agent(
    role="Financial Quant Analyst",
    goal="Audit growth, margins, cash flow, and valuation ratios; align valuation method with the business phase.",
    backstory="Data-driven analyst ensuring qualitative narratives match financial reality.",
    tools=[investment_data_tool],
    verbose=True,
    allow_delegation=False,
)


# -------------------------
# 4) TASKS
# -------------------------

task_price_sentiment = Task(
    description=r"""
You are analyzing {ticker} for the past year.

You MUST:
1) Call price_sentiment_data_tool({ticker}) for price stats and dates.
2) Use the search tool to gather catalysts + sentiment signals across the same period:
   - earnings reactions, analyst actions, major product launches, macro/regulatory headlines
   - analyst targets/ratings (link sources)
   - investor positioning/flows ONLY if verifiable; otherwise explicitly say "Limited public data found."
   - media tone from reputable outlets (link sources)
3) OPTIONAL (if X_BEARER_TOKEN exists): call x_recent_posts_tool with a query like:
   '({ticker} OR ${ticker}) (stock OR earnings OR guidance) -is:retweet lang:en'
   If not available, do NOT guess social sentiment; state "Limited social data available."

Output rules:
- Never speculate. Never hype.
- No fake links. Every claim must be backed by a link in the bullet where it appears.
- Use bullet points only in bull/bear sections.
- Always include at least 2 bull + 2 bear points; if not enough coverage, write "Limited recent coverage" and explain briefly.

OUTPUT ONLY THE TEMPLATE BELOW (fill all fields you can, and leave unknowns as "N/A" without guessing):

üìä Price & Sentiment Analysis: [Company Name] ([Ticker])
Using price data from [Start Date] ‚Äì [End Date] and news from the same period

üß† 1) Overall Takeaway
* Why It Moved: [2 sentences linking cause ‚Üí effect ‚Üí impact]
* Next Catalyst: [Upcoming event / earnings date / major launch]
* Outlook (12M): üü¢ Bullish / üü° Neutral / üî¥ Bearish ‚Äî [Plain-English summary referencing bull/bear case]

üß≠ 2) Sentiment Snapshot
| Perspective | Tone | Confidence |
| :--- | :--- | :--- |
| **Analyst** | üü¢ Bullish / üü° Neutral / üî¥ Bearish | High / Med / Low |
| **Investor** | üü¢ Bullish / üü° Neutral / üî¥ Bearish | High / Med / Low |
| **Media** | üü¢ Positive / üü° Mixed / üî¥ Negative | ‚Äî |

Tone Summary (12 Months): [1-sentence evolution of mood]
Key Signals:
* [Signal] ‚Üí [Brief summary + link]
* [Signal] ‚Üí [Brief summary + link]

üêÇ 3) What the Bulls Say
* [Reason 1 + link]
* [Reason 2 + link]
* [Reason 3 + link (or "Limited recent coverage.")]

üêª 4) What the Bears Say
* [Reason 1 + link]
* [Reason 2 + link]
* [Reason 3 + link (or "Limited recent coverage.")]

üìà 5) 1-Year Price Overview
| Metric | Value |
| :--- | :--- |
| **1-Year Change** | +X% / -X% |
| **52-Week Range** | $LOW ‚Äì $HIGH |
| **Current Price** | $XXX |
| **vs 200-Day MA** | Above / Below / At |
| **vs S&P 500** | Outperform / Underperform by X pp |

Price Context: [Short reason for current level]

üìö 6) Sources & Links
1. [Source name] ‚Äî URL
2. [Source name] ‚Äî URL
3. [Source name] ‚Äî URL
4. [Source name] ‚Äî URL

STOP HERE - DO NOT ADD ANY ADDITIONAL SECTIONS
""",
    expected_output="ONLY the filled template.",
    agent=sentiment_analyst,
)


# Dedicated business phase task that outputs ONLY your template.
task_business_phase = Task(
    description=r"""
You MUST follow this exact process for {ticker}:
1) Use investment_data_tool to get company_name, business_phase_inputs, and business_phase_classification.
2) Use the most recent SEC filing link in business_phase_inputs.latest_sec_url as the source.
   If the URL is missing, use any 10-Q/10-K link from sec_links.
3) Apply the phase decision exactly as provided by business_phase_classification (do not invent a different phase).
4) OUTPUT ONLY the template below and NOTHING else. No preamble. No commentary.

PHASE DEFINITIONS & VALUATION METHODS (use ONLY the ones for the chosen phase):

Phase 1: STARTUP
- Valuation Methods: Forward Price to Sales, Total Addressable Market (TAM)
- Why These Fit: Company is pre-profit with expanding losses. Valuation relies on future revenue potential and market opportunity size.
- Avoid: P/E ratios, DCF models, any earnings-based methods

Phase 2: HYPERGROWTH
- Valuation Methods: Forward Price to Sales, Price to Gross Profit
- Why These Fit: Company shows improving unit economics with shrinking losses. Valuation focuses on revenue trajectory and gross profit margins.
- Avoid: P/E ratios, DCF models

Phase 3: SELF FUNDING
- Valuation Methods: Price to Sales, Price to Gross Profit
- Why These Fit: Company is near breakeven, validating its business model. Current revenue and gross profit provide reliable valuation anchors.
- Avoid: Forward/Trailing P/E, Reverse DCF

Phase 4: OPERATING LEVERAGE
- Valuation Methods: Forward Price to Earnings, Forward Price to Free Cash Flow
- Why These Fit: Company demonstrates scalable profitability. Forward earnings and cash flow reflect the trajectory.
- Avoid: Dividend yield models

Phase 5: CAPITAL RETURN
- Valuation Methods: Trailing Price to Earnings, Trailing Price to Free Cash Flow, Reverse DCF
- Why These Fit: Company is mature with stable operations and capital returns. Current earnings and cash generation drive valuation.
- Avoid: High growth multiples, forward P/S

Phase 6: DECLINE
- Valuation Methods: Price to Book, Liquidation Value, Asset-Based Valuation
- Why These Fit: Traditional growth valuation methods are unreliable for declining businesses due to deteriorating fundamentals.
- Avoid: Growth multiples, forward earnings, DCF


OUTPUT TEMPLATE - ONLY OUTPUT WHAT‚ÄôS BELOW THIS LINE

# üìä Business Phase Analysis: [Company Name]

| Category | Value |
| :--- | :--- |
| **Current Stage** | [Emoji] Phase [#]: [Name] |
| **Stage Confidence Level** | ‚úÖ High / ‚ö†Ô∏è Medium / ‚ùå Low |
| **Evidence** | ‚Ä¢ Operating Income: $[X]M ([improving/worsening/positive/negative]) <br> ‚Ä¢ Revenue Growth: [X]% <br> ‚Ä¢ Capital Returns: [Yes/No with specifics] |
| **Most Useful Valuation Method(s)** | [List from approved methods for this phase only] |
| **Why These Methods Fit** | [Use exact pre-approved rationale for this phase] |
| **Methods to Avoid** | [List other common valuation methods not approved for this phase] |

## üí° Here's what this means for investors:
‚Üì
- **What they're doing:** [Simple explanation of company's focus at this stage]
- **Why it matters:** [What this tells us about the company's health]
- **How to value it:** Focus on [key metrics for this phase] using methods like [primary valuation method]
- **What to watch:** [Key indicator for this phase]

## üîó Sources
- [[Company] latest filing]([SEC URL])
- Business Growth Cycle Visual

STOP HERE - DO NOT ADD ANY ADDITIONAL SECTIONS
""",
    expected_output="ONLY the filled template.",
    agent=phase_classifier,
)

task_business_moat = Task(
    description="""Using the output of the Business Phase task as context, perform Moat + Growth analysis for {ticker}.

You MUST:
1) Use the search tool to find 5‚Äì8 high-signal sources (company IR, investor presentation, credible industry analysis, competitor pages).
2) Select the best 2‚Äì4 sources and use ScrapeWebsiteTool to extract specific evidence.
3) Include a short "Sources" section at the end listing 4‚Äì8 URLs used.

Cover:
- moat source(s): network effects, switching costs, brand, scale, regulatory, IP, distribution
- moat trend: widening / stable / shrinking + why (tie to evidence)
- growth sources: new customers vs higher spend vs product expansion vs pricing
Keep it consistent with the business phase.""",
    expected_output="Qualitative report on moat durability and growth sources (with Sources URLs).",
    agent=strategist,
    context=[task_business_phase],
)


task_management_risk = Task(
    description="""Perform management alignment + key risk analysis for {ticker}.

You MUST:
1) Use the search tool to find at least 3 sources about management incentives/comp, ownership, buybacks/dividends intent, major controversies, or governance signals.
2) Use ScrapeWebsiteTool on the most relevant 1‚Äì3 links to extract supporting details.
3) Include a "Sources" section at the end listing the URLs you used.

Also:
- Use SEC links (proxy/10-K/10-Q) to assess incentives, dilution, buybacks/dividends.
- Use transcript excerpt to flag candor vs buzzwords.
- Identify 3‚Äì6 key risks (competition, disruption, concentration, regulation, cyclicality, execution).""",
    expected_output="Audit of management alignment and key execution risks (with Sources URLs).",
    agent=governance_expert,
    context=[task_business_phase, task_business_moat],
)


task_quant_valuation = Task(
    description="""Perform quant verification + valuation summary for {ticker}:
- Use tool output (metrics/growth/income statement) to report: revenue trend, operating margin, FCF signal if available, and any obvious red flags.
- Provide valuation ratios if available from metrics; align suggested valuation method with the Business Phase output.
- Call out any mismatch between story and numbers.""",
    expected_output="Quantitative verification and valuation summary.",
    agent=quant_auditor,
    context=[task_business_phase, task_business_moat, task_management_risk],
)


# -------------------------
# 5) CREW ASSEMBLY & EXECUTION
# -------------------------
investment_crew = Crew(
    agents=[sentiment_analyst, phase_classifier, strategist, governance_expert, quant_auditor],
    tasks=[task_price_sentiment, task_business_phase, task_business_moat, task_management_risk, task_quant_valuation],
    process=Process.sequential,
    verbose=True,
)

ticker_to_analyze = input("Enter a ticker symbol: ").strip().upper()
print(f"\n### Starting Analysis for {ticker_to_analyze} ###\n")

result = investment_crew.kickoff(inputs={"ticker": ticker_to_analyze})


# -------------------------
# 6) CONSOLIDATED OUTPUT DISPLAY
# -------------------------
print("\n\n" + "=" * 60)
print(f"FINAL CONSOLIDATED REPORT: {ticker_to_analyze}")
print("=" * 60 + "\n")

section_names = ["BUSINESS PHASE", "BUSINESS & MOAT", "MANAGEMENT & RISK", "QUANT & VALUATION"]
for i, task_output in enumerate(result.tasks_output):
    name = section_names[i] if i < len(section_names) else f"SECTION {i+1}"
    print(f"### {name} ###\n")
    print(task_output.raw)
    print("\n" + "-" * 40 + "\n")

# Save to file
report_md = f"{ticker_to_analyze}_report.md"
report_pdf = f"{ticker_to_analyze}_report.pdf"

section_names = ["PRICE & SENTIMENT", "BUSINESS PHASE", "BUSINESS & MOAT", "MANAGEMENT & RISK", "QUANT & VALUATION"]

with open(report_md, "w", encoding="utf-8") as f:
    f.write(f"# Investment Analysis Report: {ticker_to_analyze}\n\n")
    f.write(f"_Generated via CrewAI + FMP + Web Research tools._\n\n")
    # optional: include run timestamp
    # from datetime import datetime
    # f.write(f"_Run time: {datetime.now().isoformat(timespec='seconds')}_\n\n")

    for i, task_output in enumerate(result.tasks_output):
        name = section_names[i] if i < len(section_names) else f"Section {i+1}"
        f.write(f"## {name}\n\n")
        f.write(task_output.raw.strip() + "\n\n")

print(f"Saved markdown to: {report_md}")

# Convert to PDF
md_to_pdf_pandoc(report_md, report_pdf, title=f"Investment Analysis Report: {ticker_to_analyze}")
print(f"Saved PDF to: {report_pdf}")

